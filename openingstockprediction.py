# -*- coding: utf-8 -*-
"""OpeningStockPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/128VF3RzPa8FA85fFfXAj9wkJMyPAH-O1

importing libraries
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sklearn
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

"""Reading the training dataset and retriving the opening stock column And"""

df = pd.read_csv("Google_Stock_Price_Train.csv")
train_dataset = df.iloc[:,1:2].values
#Performing the scaling operation to fit all values between 0 and 1
sc = sklearn.preprocessing.MinMaxScaler(feature_range=(0,1))
scaled_dataset = sc.fit_transform(train_dataset)

"""Creation of training array"""

X_train = []
Y_train = []
for i in range(60, len(scaled_dataset)):
  X_train.append(scaled_dataset[i-60:i,0])
  Y_train.append(scaled_dataset[i,0])
X_train = np.array(X_train)
Y_train = np.array(Y_train)

X_train = np.reshape(X_train,(X_train.shape[0], X_train.shape[1], 1))

regressor = Sequential()

"""Applying the LSTM first Layer"""

regressor.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1],1)))
regressor.add(Dropout(0.2))

"""Applying Second Layer with same Droupout time"""

regressor.add(LSTM(units=50, return_sequences=True))
regressor.add(Dropout(0.2))

"""Applying Third Layer with same Droupout time"""

regressor.add(LSTM(units=50, return_sequences=True))
regressor.add(Dropout(0.2))

"""Applying Final Layer with same Droupout time"""

regressor.add(LSTM(units=50))
regressor.add(Dropout(0.2))

"""Final Output neuron"""

regressor.add(Dense(units=1))

"""Optimmising and reducing the loss"""

regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')

"""Training the Dataset"""

regressor.fit(X_train, Y_train, epochs = 100, batch_size = 32)

"""Creation of testing dataset"""

test = pd.read_csv("Google_Stock_Price_Test.csv")
stock_price = test.iloc[:,1:2].values

total = pd.concat((df['Open'], test['Open']), axis =0)
inputs = total[(len(total)-len(test)-60):].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)

X_test = []
for i in range(60,80):
  X_test.append(inputs[i-60:i,0])
X_test = np.array(X_test)
X_test = np.reshape(X_test, (X_test.shape[0],X_test.shape[1],1))
#Predicting the final results
prediction = regressor.predict(X_test)
#Amplifying the values obtained between 0 to 1 
prediction = sc.inverse_transform(prediction)

"""Plotting the curve for visualization"""

plt.style.use('seaborn')
plt.plot(stock_price, color='red', label ='Real stock price')
plt.plot(prediction, color='blue', label ="Predicted stock price")
plt.title('Prediction vs Real')
plt.xlabel('Time')
plt.ylabel('Stock Price')
plt.legend()
plt.show()